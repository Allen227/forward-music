{"version":3,"sources":["page/song/index.tsx","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","container/song/index.tsx"],"names":["parsedResult","getActiveIndex","preIndex","searchTime","index","resultIndex","o","Symbol","iterator","Array","isArray","unsupportedIterableToArray","i","F","s","n","length","done","value","e","_e","f","TypeError","it","err","normalCompletion","didErr","step","next","_e2","time","includes","connect","state","dispatch","fetchLyric","songId","actions","computedCurLine","lyricData","curSongInfo","location","useLocation","timeContext","useContext","currentTimeContext","useState","currentLine","setCurrentLine","id","useEffect","lyricListDom","document","querySelector","style","top","removeAttribute","lyricStr","lrc","lyric","lyricArr","split","matchInfo","map","line","match","push","slice","trim","lyricDom","lyricStyle","parseTime","className","join","key"],"mappings":"8NAkBIA,G,OAAoB,IAElBC,EAAkB,WACtB,IAAIC,GAAY,EAChB,OAAO,SAAyBC,GAC9B,IADkD,EAC9CC,EAAQ,EACRC,OAAkC,EAFY,ECrBvC,SAAoCC,GACjD,GAAsB,qBAAXC,QAAgD,MAAtBD,EAAEC,OAAOC,UAAmB,CAC/D,GAAIC,MAAMC,QAAQJ,KAAOA,EAAI,OAAAK,EAAA,GAA2BL,IAAK,CAC3D,IAAIM,EAAI,EAEJC,EAAI,aAER,MAAO,CACLC,EAAGD,EACHE,EAAG,WACD,OAAIH,GAAKN,EAAEU,OAAe,CACxBC,MAAM,GAED,CACLA,MAAM,EACNC,MAAOZ,EAAEM,OAGbO,EAAG,SAAWC,GACZ,MAAMA,GAERC,EAAGR,GAIP,MAAM,IAAIS,UAAU,yIAGtB,IAAIC,EAGAC,EAFAC,GAAmB,EACnBC,GAAS,EAEb,MAAO,CACLZ,EAAG,WACDS,EAAKjB,EAAEC,OAAOC,aAEhBO,EAAG,WACD,IAAIY,EAAOJ,EAAGK,OAEd,OADAH,EAAmBE,EAAKV,KACjBU,GAETR,EAAG,SAAWU,GACZH,GAAS,EACTF,EAAMK,GAERR,EAAG,WACD,IACOI,GAAoC,MAAhBF,EAAW,QAAWA,EAAW,SAC1D,QACA,GAAIG,EAAQ,MAAMF,KD5B4B,CAG1BxB,GAH0B,IAGlD,2BAAsC,CACpC,GADoC,QACpB8B,KAAKC,SAAS5B,GAAa,CACzCE,EAAcD,EACd,MAEFA,KARgD,8BAelD,YALoB,IAAhBC,EACFA,EAAcH,EAEdA,EAAWG,EAENA,GAjBa,G,YEPT2B,uBAVf,SAAyBC,GACvB,OAAOA,KAGT,SAA4BC,GAC1B,MAAO,CACLC,WAAY,SAACC,GAAD,OAAoBF,EAASG,IAAmBD,QAIjDJ,EF4BA,YAA6D,IAmDtEM,EAnDyBH,EAA4C,EAA5CA,WAAYI,EAAgC,EAAhCA,UAAWC,EAAqB,EAArBA,YAChDC,EAAyBC,cACzBC,EAAcC,qBAAWC,KAF4C,EAGnCC,mBAAS,GAH0B,mBAGlEC,EAHkE,KAGrDC,EAHqD,KAInEZ,EAASK,EAASR,MAAMgB,GAE9BC,qBAAU,WACR,IAAIC,EAAoBC,SAASC,cAAc,eAC3CF,GAAgBJ,EAAc,IAChCI,EAAaG,MAAMC,IAAnB,WAAiD,IAAnBR,EAAc,GAA5C,SAED,CAACA,IAGJG,qBAAU,WACJd,GACFD,EAAWC,KAEZ,IAEHc,qBAAU,WACR,IAAIC,EAAoBC,SAASC,cAAc,eAC/CL,EAAe,GACfG,EAAaK,gBAAgB,WAC5B,CAAChB,IAEJU,qBAAU,WACRlD,EAAe,GACf,IAAIyD,EAAmB,GACnBlB,GAAaA,EAAUmB,MACzBD,EAAWlB,EAAUmB,IAAIC,OAG3B3D,EAAgB,WAEd,IAAM4D,EAAWH,EAASI,MAAM,MAC5BC,EAAiB,GAYrB,OAVAF,EAASG,KAAI,SAAAC,IACXF,EAAYE,EAAKC,MAAM,mCAGrBjE,EAAakE,KAAK,CAChBpC,KAAMgC,EAAU,GAAGK,MAAM,GAAI,GAC7BjD,MAAO8C,EAAKG,MAAML,EAAU,GAAG9C,QAAQoD,YAItCpE,EAfO,MAoBlB,IAAIqE,EAAWrE,EAAa+D,KAAI,SAACC,EAAiB5D,GAChD,IAAMkE,EAAa,CAAC,cASpB,OARAhC,EAAkBrC,EAAesE,YAA8B,IAApB5B,EAAYzB,WAE/B6B,GACtBC,EAAeV,GAEbS,IAAgB3C,GAClBkE,EAAWJ,KAAK,UAGhB,wBAAIM,UAAWF,EAAWG,KAAK,KAAMC,IAAKtE,GAAQ4D,EAAK9C,UAG3D,OACE,yBAAKsD,UAAU,QACb,wBAAIA,UAAU,cAAcH","file":"static/js/6.e1c0b616.chunk.js","sourcesContent":["import React, {useState, useEffect, useContext} from 'react';\r\nimport {useLocation} from 'react-router-dom';\r\nimport {lyricType, curSongInfoType} from '../../types/index';\r\nimport parseTime from '../../plugin/parseTime';\r\nimport {currentTimeContext} from '../../plugin/currentTimeContext';\r\nimport './style.pcss';\r\n\r\ninterface locationType {\r\n  state: any\r\n}\r\n\r\ninterface Props {\r\n  curSongInfo: curSongInfoType,\r\n  currentTime: number,\r\n  fetchLyric: Function,\r\n  lyricData: any\r\n}\r\n\r\nlet parsedResult: any = [];\r\n// get current line that is active of lyric\r\nconst getActiveIndex = (function () {\r\n  let preIndex = -1;\r\n  return function getActiveIndex (searchTime: string) {\r\n    let index = 0;\r\n    let resultIndex: number | undefined = void 0;\r\n    for (let currentLine of parsedResult) {\r\n      if (currentLine.time.includes(searchTime)) {\r\n        resultIndex = index;\r\n        break;\r\n      }\r\n      index++;\r\n    }\r\n    if (resultIndex === void 0) {\r\n      resultIndex = preIndex;\r\n    } else {\r\n      preIndex = resultIndex;\r\n    }\r\n    return resultIndex;\r\n  }\r\n})();\r\n\r\nexport default function Song ({fetchLyric, lyricData, curSongInfo}: Props) {\r\n  let location: locationType = useLocation();\r\n  let timeContext = useContext(currentTimeContext);\r\n  const [currentLine, setCurrentLine] = useState(0);\r\n  const songId = location.state.id;\r\n  // set lyrics animation that move upward\r\n  useEffect(() => {\r\n    let lyricListDom: any = document.querySelector('.lyric-list');\r\n    if (lyricListDom && currentLine > 7) {\r\n      lyricListDom.style.top = `-${(currentLine - 7) * 30}px`;\r\n    }\r\n  }, [currentLine])\r\n  // fetch lyric\r\n  /* eslint-disable */\r\n  useEffect(() => {\r\n    if (songId) {\r\n      fetchLyric(songId);\r\n    }\r\n  }, []);\r\n  // init currentLine when song change\r\n  useEffect(() => {\r\n    let lyricListDom: any = document.querySelector('.lyric-list');\r\n    setCurrentLine(0);\r\n    lyricListDom.removeAttribute('style');\r\n  }, [curSongInfo])\r\n  // initial parsedResult\r\n  useEffect(() => {\r\n    parsedResult = [];\r\n    let lyricStr: string = '';\r\n    if (lyricData && lyricData.lrc) {\r\n      lyricStr = lyricData.lrc.lyric;\r\n    }\r\n    /** parse lyric **/\r\n    parsedResult = (function parseLyric() {\r\n      // split string for get lyric array\r\n      const lyricArr = lyricStr.split('\\n');\r\n      let matchInfo: any = [];\r\n      // listen audio time\r\n      lyricArr.map(line => {\r\n        matchInfo = line.match(/\\[\\d{2}:\\d{2}.(\\d{2}|\\d{3})\\]/);\r\n        if (matchInfo) {\r\n          // push into result stack\r\n          parsedResult.push({\r\n            time: matchInfo[0].slice(1, -1),\r\n            value: line.slice(matchInfo[0].length).trim()\r\n          })\r\n        }\r\n      });\r\n      return parsedResult;\r\n    })();\r\n  });\r\n  let computedCurLine;\r\n  // get node of lyric\r\n  let lyricDom = parsedResult.map((line: lyricType, index: number) => {\r\n    const lyricStyle = ['lyric-line'];\r\n    computedCurLine = getActiveIndex(parseTime(timeContext.value * 1e3));\r\n    // set new current line if not find current line\r\n    if (computedCurLine !== currentLine) {\r\n      setCurrentLine(computedCurLine);\r\n    }\r\n    if (currentLine === index) {\r\n      lyricStyle.push('active');\r\n    }\r\n    return (\r\n      <li className={lyricStyle.join(' ')} key={index}>{line.value}</li>\r\n    )\r\n  })\r\n  return (\r\n    <div className=\"song\">\r\n      <ul className=\"lyric-list\">{lyricDom}</ul>\r\n    </div>\r\n  )\r\n}","import unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nexport default function _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","import {connect} from 'react-redux';\r\nimport Song from '../../page/song/index';\r\nimport * as actions from '../../store/actions';\r\nfunction mapStateToProps(state: object) {\r\n  return state;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: any) {\r\n  return {\r\n    fetchLyric: (songId: number) => dispatch(actions.fetchLyric(songId))\r\n  }\r\n};\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(Song);"],"sourceRoot":""}